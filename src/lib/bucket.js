import NamedColors from './named-colors';

/** Much faster than flat array or regexp */
export default class Bucket {
  constructor(src) {
    /** @type {Map<number, string|string[]>} */
    this.map = new Map();
    this.addFrom(src);
  }

  /**
   * @param {string|string[]} src - length < 100
   * @return {Bucket}
   */
  addFrom(src) {
    for (let str of typeof src === 'string' ? [src] : src) {
      let c = (str = str.toLowerCase()).charCodeAt(0);
      if (c === 34 /* " */) c = (str = str.slice(1, -1)).charCodeAt(0);
      src = this.map.get(c = c * 100 + str.length);
      if (src == null) this.map.set(c, str);
      else if (typeof src === 'string') this.map.set(c, [src, str]);
      else src.push(str);
    }
    return this;
  }

  /** @return {string} */
  join(sep) {
    const res = [];
    for (const v of this.map.values()) {
      if (typeof v === 'string') res.push(v);
      else res.push(...v);
    }
    return res.join(sep);
  }

  /**
   * @param {Token} tok
   * @param {string} [lowText] - text to use instead of token's text
   * @param {number} [vendorPos] - check ignoring vendor prefix
   * @return {boolean}
   */
  has(tok, lowText, vendorPos) {
    let val;
    let low = lowText ?? tok.lowText;
    let len = (low ?? tok).length;
    if (len >= 100 || (val =
      this.map.get(
        (vendorPos ? tok.vendorCode : tok.code) * 100 +
        (vendorPos ? len -= vendorPos : len))
    ) == null) return false;
    if (len === 1) return true;
    low ??= tok.lowText = tok.text.toLowerCase();
    return val === low || (
      typeof val === 'object' ? val.includes(vendorPos ? low.slice(vendorPos) : low)
        : vendorPos ? low.endsWith(val) : false);
  }
}

export const B = /** @type {{[key:string]: Bucket}} */ {
  attrIS: ['i', 's', ']'], // "]" is to improve the error message,
  calc: ['abs', 'calc', 'calc-size', 'clamp', 'if', 'min', 'max', 'mod',
    'progress', 'rem', 'round', 'sign'],
  colors: NamedColors,
  containerFn: ['scroll-state(', 'style('],
  marginSyms: [
    'bottom-center', 'bottom-left-corner', 'bottom-left', 'bottom-right-corner', 'bottom-right',
    'left-bottom', 'left-middle', 'left-top',
    'right-bottom', 'right-middle', 'right-top',
    'top-center', 'top-left-corner', 'top-left', 'top-right-corner', 'top-right',
  ],
  // autogenerated:
  and: null,
  andNoneNotOr: null,
  andOr: null,
  auto: null,
  evenOdd: null,
  fromTo: null,
  important: null,
  layer: null,
  n: null,
  none: null,
  not: null,
  notOnly: null,
  of: null,
  or: null,
  returns: null,
  to: null,
};
for (const k in B)
  B[k] = new Bucket(B[k] || k.split(/(?=[A-Z])/)); // splitting by an Uppercase A-Z letter
